{"meta":{"title":"BobJiang","subtitle":"实践即真理","description":null,"author":"BobJiang","url":"https://jmyok.github.io"},"pages":[],"posts":[{"title":"PAT甲1159 Structure of a Binary Tree （30分）","slug":"PAT1159","date":"2019-07-22T03:02:58.000Z","updated":"2019-07-22T03:34:02.357Z","comments":true,"path":"2019/07/22/PAT1159/","link":"","permalink":"https://jmyok.github.io/2019/07/22/PAT1159/","excerpt":"","text":"Structure of a Binary TreeSuppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, a binary tree can be uniquely determined. Now given a sequence of statements about the structure of the resulting tree, you are supposed to tell if they are correct or not. A statment is one of the following: A is the root A and B are siblings A is the parent of B A is the left child of B A is the right child of B A and B are on the same level It is a full treeNote:Two nodes are on the same level, means that they have the same depth.A full binary tree is a tree in which every node other than the leaves has two children.Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are no more than 10^​3​​ and are separated by a space. Then another positive integer M (≤30) is given, followed by M lines of statements. It is guaranteed that both A and B in the statements are in the tree. Output Specification:For each statement, print in a line Yes if it is correct, or No if not. Sample Input:1234567891011916 7 11 32 28 2 23 8 1516 23 7 32 11 2 28 15 8715 is the root8 and 2 are siblings32 is the parent of 1123 is the left child of 1628 is the right child of 27 and 11 are on the same levelIt is a full tree Sample Output:1234567YesNoYesNoYesYesYes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;int pos[40], in[40];map&lt;int, int&gt;siblings,leftc,rightc,parent,levels;bool isfulltree = true;struct node&#123; int data; node* lchild=NULL, *rchild=NULL;&#125;;node* create(int posL, int posR, int inL, int inR)&#123; if (posL &gt; posR)return NULL; node *root = new node; int key = pos[posR]; root-&gt;data = key; int k = inL; while (in[k] != key&amp;&amp;k &lt;= inR)k++; int numLeft = k - inL; root-&gt;lchild = create(posL, posL + numLeft - 1, inL, k - 1); root-&gt;rchild = create(posL + numLeft, posR - 1, k + 1, inR); return root;&#125;//一次将所有结果搜索完void dfs(node* root, int level)&#123; if (root == NULL)return; levels[root-&gt;data] = level; if ((root-&gt;lchild == NULL&amp;&amp;root-&gt;rchild != NULL) || (root-&gt;rchild == NULL&amp;&amp;root-&gt;lchild != NULL))isfulltree = false; if (root-&gt;lchild != NULL||root-&gt;rchild!=NULL)&#123; if (root-&gt;lchild != NULL)&#123; leftc[root-&gt;data] = root-&gt;lchild-&gt;data; parent[root-&gt;lchild-&gt;data] = root-&gt;data; dfs(root-&gt;lchild, level + 1); &#125; if (root-&gt;rchild != NULL)&#123; rightc[root-&gt;data] = root-&gt;rchild-&gt;data; parent[root-&gt;rchild-&gt;data] = root-&gt;data; dfs(root-&gt;rchild, level + 1); &#125; if (root-&gt;lchild != NULL &amp;&amp;root-&gt;rchild != NULL)&#123; siblings[root-&gt;lchild-&gt;data] = root-&gt;rchild-&gt;data; siblings[root-&gt;rchild-&gt;data] = root-&gt;lchild-&gt;data; &#125; &#125;&#125;int main()&#123; int n,m; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++)scanf(&quot;%d&quot;, &amp;pos[i]); for (int i = 0; i &lt; n; i++)scanf(&quot;%d&quot;, &amp;in[i]); node *root = create(0, n - 1, 0, n - 1); dfs(root, 1); scanf(&quot;%d&quot;, &amp;m); string q; getchar(); for (int i = 0; i &lt; m; i++)&#123; getline(cin, q); if (q.find(&quot;root&quot;) != string::npos)&#123; if (root-&gt;data == stoi(q.substr(0,q.size()-12)))printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125; else if (q.find(&quot;full tree&quot;) != string::npos)&#123; if (isfulltree)printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125; else if (q.find(&quot;parent&quot;) != string::npos)&#123; int a, b; sscanf(q.c_str(), &quot;%d is the parent of %d&quot;, &amp;a, &amp;b); printf(&quot;%s&quot;, parent[b] == a ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); &#125; else if (q.find(&quot;left child&quot;) != string::npos)&#123; int a, b; sscanf(q.c_str(), &quot;%d is the left child of %d&quot;, &amp;a, &amp;b); printf(&quot;%s&quot;, leftc[b] == a ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); &#125; else if (q.find(&quot;siblings&quot;) != string::npos)&#123; int a, b; sscanf(q.c_str(), &quot;%d and %d are siblings&quot;, &amp;a, &amp;b); printf(&quot;%s&quot;, siblings[b] == a ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); &#125; else if (q.find(&quot;right child&quot;) != string::npos)&#123; int a, b; sscanf(q.c_str(), &quot;%d is the right child of %d&quot;, &amp;a, &amp;b); printf(&quot;%s&quot;, rightc[b] == a ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); &#125; else if (q.find(&quot;level&quot;) != string::npos)&#123; int a, b; sscanf(q.c_str(), &quot;%d and %d are on the same level&quot;, &amp;a, &amp;b); printf(&quot;%s&quot;, levels[a]==levels[b]? &quot;Yes\\n&quot; : &quot;No\\n&quot;); &#125; &#125;&#125; dfs搜索所有结果，关键是sscanf的运用，从字符串中提取数字。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jmyok.github.io/categories/数据结构/"}],"tags":[{"name":"PAT甲","slug":"PAT甲","permalink":"https://jmyok.github.io/tags/PAT甲/"}]},{"title":"PAT甲1158 Telefraud Detection（25分）","slug":"PAT1158","date":"2019-07-22T02:59:57.000Z","updated":"2019-07-22T03:27:59.644Z","comments":true,"path":"2019/07/22/PAT1158/","link":"","permalink":"https://jmyok.github.io/2019/07/22/PAT1158/","excerpt":"","text":"Telefraud DetectionTelefraud（电信诈骗） remains a common and persistent problem in our society. In some cases, unsuspecting victims lose their entire life savings. To stop this crime, you are supposed to write a program to detect those suspects from a huge amount of phone call records. A person must be detected as a suspect if he/she makes more than K short phone calls to different people everyday, but no more than 20% of these people would call back. And more, if two suspects are calling each other, we say they might belong to the same gang. A makes a short phone call to B means that the total duration of the calls from A to B is no more than 5 minutes. Input Specification:Each input file contains one test case. For each case, the first line gives 3 positive integers K (≤500, the threshold（阈值） of the amount of short phone calls), N (≤10^3, the number of different phone numbers), and M (≤10^5 , the number of phone call records). Then M lines of one day’s records are given, each in the format: caller receiver durationwhere caller and receiver are numbered from 1 to N, and duration is no more than 1440 minutes in a day. Output Specification:Print in each line all the detected suspects in a gang, in ascending order of their numbers. The gangs are printed in ascending order of their first members. The numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line. If no one is detected, output None instead. Sample Input 1:12345678910111213141516171819202122232425262728293031325 15 311 4 21 5 21 5 41 7 51 8 31 9 11 6 51 15 21 15 53 2 23 5 153 13 13 12 13 14 13 10 23 11 55 2 15 3 105 1 15 7 25 6 15 13 45 15 111 10 512 14 16 1 16 9 26 10 56 11 26 12 16 13 1 Sample Output 1:123 56 Note:In sample 1, although 1 had 9 records, but there were 7 distinct receivers, among which 5 and 15 both had conversations lasted more than 5 minutes in total. Hence 1 had made 5 short phone calls and didn’t exceed the threshold 5, and therefore is not a suspect. Sample Input 2:1234567895 7 81 2 11 3 11 4 11 5 11 6 11 7 12 1 13 1 1 Sample Output 2:1None 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;//suspect:&gt;K个short电话,总时长&lt;=5minutes，&lt;=0.2的人回电话//两个suspect互相都有通话属于一个帮派//按照第一个成员的number上升序输出帮派，每个帮派里按照成员number上升序输出vector&lt;int&gt;suspects;int cnt[1024][1024]; //记录通话int father[1024];int findFather(int x)&#123; return x == father[x] ? x : father[x] = findFather(father[x]); //路径压缩&#125;int main()&#123; int K, N, M; scanf(&quot;%d%d%d&quot;, &amp;K, &amp;N, &amp;M); int caller, receiver, d; for (int i = 0; i &lt; M; i++)&#123; scanf(&quot;%d%d%d&quot;, &amp;caller, &amp;receiver, &amp;d); cnt[caller][receiver] += d; &#125; //得到嫌疑人 for (int i = 1; i &lt;= N; i++)&#123; int sum = 0, rsum = 0; for (int j = 1; j &lt;= N; j++)&#123; if (cnt[i][j]&gt;0 &amp;&amp; cnt[i][j] &lt;= 5)&#123; sum++; if (cnt[j][i] &gt; 0) rsum++; //回电话人数 &#125; &#125; if (sum &gt; K)&#123; suspects.push_back(i); if ((1.0*rsum) / sum &gt; 0.2)suspects.pop_back(); &#125; &#125; //找出帮派 for (int i = 1; i &lt; N; i++)father[i] = i; int sz = suspects.size(); for (int i = 0; i &lt; sz; i++)&#123; for (int j = i+1; j &lt; sz; j++)&#123; if (cnt[suspects[i]][suspects[j]]&gt;0 &amp;&amp; cnt[suspects[j]][suspects[i]] &gt; 0)&#123; //嫌疑人间有关系 int f1 = findFather(suspects[i]); int f2 = findFather(suspects[j]); if (f1 != f2)&#123; if (f1 &lt; f2)swap(f1, f2); father[f1] = f2; //值小的当老大，便于用map排序gang &#125; &#125; &#125; &#125; map&lt;int, vector&lt;int&gt;&gt; mp; for (int i = 0; i &lt; sz; i++)&#123; int L = findFather(suspects[i]); mp[L].push_back(suspects[i]); &#125; if (mp.size() == 0)&#123; printf(&quot;None\\n&quot;); return 0; &#125; for (auto x : mp)&#123; sort(x.second.begin(), x.second.end());//gang内排序 int ts = x.second.size(); for (int i = 0; i &lt; ts; i++)&#123; printf(&quot;%d%c&quot;, x.second[i], i == ts - 1 ? &apos;\\n&apos; : &apos; &apos;); &#125; &#125;&#125; 个人觉得这是25分里面最难的题，要筛嫌疑人，筛完还要并查集找帮派，还要合理处理排序。条件理解不清楚就做不出来，比如要注意是++total duration++，以及calling ++each other++，只有一方通话不算。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jmyok.github.io/categories/数据结构/"}],"tags":[{"name":"PAT甲","slug":"PAT甲","permalink":"https://jmyok.github.io/tags/PAT甲/"}]},{"title":"PAT甲-1030 Travel Plan （30 分）[dijkstra模版]","slug":"PAT甲-1030-Travel-Plan-（30-分）-dijkstra模版","date":"2019-02-28T15:20:02.000Z","updated":"2019-02-28T15:46:31.398Z","comments":true,"path":"2019/02/28/PAT甲-1030-Travel-Plan-（30-分）-dijkstra模版/","link":"","permalink":"https://jmyok.github.io/2019/02/28/PAT甲-1030-Travel-Plan-（30-分）-dijkstra模版/","excerpt":"","text":"1030 Travel Plan （30 分）A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique. Input Specification:Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format: City1 City2 Distance Cost where the numbers are all integers no more than 500, and are separated by a space. Output Specification:For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output. Sample Input:4 5 0 3 0 1 1 20 1 3 2 30 0 3 4 10 0 2 2 20 2 3 1 20 Sample Output:0 2 3 3 40 代码#include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; const int maxn = 505; const int inf = 9999999; int n, m, s, d; int G[maxn][maxn]; bool visit[maxn]; int dis[maxn]; //从起点到某点的距离 int cost[maxn][maxn]; //边权 vector&lt;int&gt; temppath, path; //路径 vector&lt;int&gt; pre[maxn]; //保存前驱 int mincost = inf; //dijsktra找到最短路径，得到前驱集合 void dijsktra(int s){ fill(dis, dis + maxn, inf); fill(visit, visit + maxn, false); dis[s] = 0; while (1){ int u = -1, min = inf; for (int i = 0; i &lt; n; i++){ if (!visit[i] &amp;&amp; dis[i] &lt; min){ u = i; min = dis[i]; } } if (u == -1)break; visit[u] = true; for (int v = 0; v &lt; n; v++){ if (!visit[v] &amp;&amp; G[u][v] != inf){ if (dis[u] + G[u][v] &lt; dis[v]){ dis[v] = dis[u] + G[u][v]; pre[v].clear(); pre[v].push_back(u); } else if (dis[u] + G[u][v] == dis[v]){ pre[v].push_back(u); } } } } } //在最短路径的情况下得到最小开销的具体路径 void dfs(int v){ if (v == s){ //递归边界 temppath.push_back(v); int tempcost=0; for (int i = 0; i+1 &lt; temppath.size(); i++) { int a = temppath[i], b = temppath[i + 1]; tempcost += cost[a][b]; } if (tempcost &lt; mincost){ mincost = tempcost; path = temppath; } temppath.pop_back(); return; } temppath.push_back(v); for (int i = 0; i &lt; pre[v].size(); i++){ //遍历前驱 dfs(pre[v][i]); } temppath.pop_back();//前驱遍历完删除 } int main(){ fill(G[0], G[0] + maxn*maxn, inf); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;d); for (int i = 0; i &lt; m; i++){ int a, b,c,d; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b,&amp;c,&amp;d); G[a][b] =G[b][a]= c; cost[a][b] = cost[b][a]=d; } dijsktra(s); dfs(d); for (int i = path.size() - 1; i &gt;= 1;i--){ printf(&quot;%d &quot;, path[i]); } printf(&quot;%d %d %d&quot;,d, dis[d], mincost); } 知识点 Djikstra+Dfs 总结 统计路径条数dijstra中就可以解决 一般题目会在当找到最短路径后，需要有第二尺度来选择最优解时： 只有点权择优的题只用Djikstra，例如A1003：“路径最短的情况下统计物资最多”的题。 根据边权以及统计具体路径的情况需要Djikstra+Dfs，例如A1030“路径最短情况下计算旅游费用的最小开销以及具体路径”","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jmyok.github.io/categories/数据结构/"}],"tags":[{"name":"PAT甲级","slug":"PAT甲级","permalink":"https://jmyok.github.io/tags/PAT甲级/"}]},{"title":"PAT甲-1146 Topological Order （25 分）","slug":"PAT甲-1146-Topological-Order-（25-分）","date":"2019-02-21T10:46:13.000Z","updated":"2019-02-28T15:47:24.321Z","comments":true,"path":"2019/02/21/PAT甲-1146-Topological-Order-（25-分）/","link":"","permalink":"https://jmyok.github.io/2019/02/21/PAT甲-1146-Topological-Order-（25-分）/","excerpt":"","text":"This is a problem given in the Graduate Entrance Exam in 2018: Which of the following is NOT a topological order obtained from the given directed graph? Now you are supposed to write a program to test each of the options. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (≤ 1,000), the number of vertices in the graph, and M (≤ 10,000), the number of directed edges. Then M lines follow, each gives the start and the end vertices of an edge. The vertices are numbered from 1 to N. After the graph, there is another positive integer K (≤ 100). Then K lines of query follow, each gives a permutation of all the vertices. All the numbers in a line are separated by a space. Output Specification:Print in a line all the indices of queries which correspond to “NOT a topological order”. The indices start from zero. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. It is graranteed that there is at least one answer. Sample Input:1234567891011121314156 81 21 35 25 42 32 63 46 451 5 2 3 6 45 1 2 6 3 45 1 2 3 6 45 2 1 6 3 41 2 3 4 5 6 Sample Output:13 4 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1005;vector&lt;int&gt;G[maxn];vector&lt;int&gt;indegree,temp,ans;//每个点的入度以及最后结果int num[maxn];int main()&#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); indegree.resize(n+1); int a,b; for (int i = 0; i &lt; m; i++)&#123; scanf(&quot;%d%d&quot;, &amp;a,&amp;b); G[a].push_back(b); indegree[b]++; &#125; //判断 int k; scanf(&quot;%d&quot;, &amp;k); for (int i = 0; i &lt; k; i++)&#123; int flag = 1;//记录是否为拓扑排序 temp = indegree; for (int j = 0; j &lt; n; j++)&#123; scanf(&quot;%d&quot;, &amp;num[j]); &#125; for (int j = 0; j &lt; n; j++)&#123; int a = num[j]; if (temp[a] != 0)&#123; //如果结点的入度不为0 flag = 0; break; &#125; else&#123; //将a的所有下个结点的入度全部减1 for (auto it = G[a].begin(); it != G[a].end(); it++)&#123; temp[*it]--; &#125; &#125; &#125; if (flag == 0) ans.push_back(i); &#125; for (auto it = ans.begin(); it != ans.end(); it++)&#123; if (it != ans.begin()) printf(&quot; &quot;); printf(&quot;%d&quot;, *it); &#125;&#125; 知识点 图 拓扑排序 解决方案关键点：遍历序列中的结点，判断其入度是否为0；因为拓扑排序的原理就是将入度为0的结点依次入队然后输入。 总结 已知为有向无环图，判断拓扑排序是否正确）（该题就是这种类型）。 根据拓扑排序，判断是否为有向无环图。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jmyok.github.io/categories/数据结构/"}],"tags":[{"name":"PAT甲级","slug":"PAT甲级","permalink":"https://jmyok.github.io/tags/PAT甲级/"}]},{"title":"激活函数的选择","slug":"激活函数的选择","date":"2018-09-17T14:00:19.000Z","updated":"2019-07-22T03:22:22.929Z","comments":true,"path":"2018/09/17/激活函数的选择/","link":"","permalink":"https://jmyok.github.io/2018/09/17/激活函数的选择/","excerpt":"","text":"几种不同的激活函数g(x)： 激活函数的选择： sigmoid函数和tanh函数比较： 隐藏层：tanh函数的表现要好于sigmoid函数，因为tanh取值范围为[−1,+1]，输出分布在0值的附近，均值为0，从隐藏层到输出层数据起到了归一化（均值为0）的效果。 输出层：对于二分类任务的输出取值为{0,1}，故一般会选择sigmoid函数。然而sigmoid和tanh函数在当|z|很大的时候，梯度会很小，在依据梯度的算法中，更新在后期会变得很慢。在实际应用中，要使|z|尽可能的落在0值附近。 ReLU弥补了前两者的缺陷，当z&gt;0时，梯度始终为1，从而提高神经网络基于梯度算法的运算速度。然而当z&lt;0时，梯度一直为0，但是实际的运用中，该缺陷的影响不是很大。 Leaky ReLU保证在z&lt;0的时候，梯度仍然不为0。在选择激活函数的时候，如果在不知道该选什么的时候就选择ReLU，当然也没有固定答案，要依据实际问题在交叉验证集合中进行验证分析。","categories":[{"name":"技术干货 机器学习","slug":"技术干货-机器学习","permalink":"https://jmyok.github.io/categories/技术干货-机器学习/"}],"tags":[{"name":"激活函数","slug":"激活函数","permalink":"https://jmyok.github.io/tags/激活函数/"}]},{"title":"tensorflow识别MNIST","slug":"tensorflow识别MNIST","date":"2018-08-14T07:07:24.000Z","updated":"2019-07-22T03:27:47.251Z","comments":true,"path":"2018/08/14/tensorflow识别MNIST/","link":"","permalink":"https://jmyok.github.io/2018/08/14/tensorflow识别MNIST/","excerpt":"","text":"数据准备简单的说，MNIST就是一组最基础的数据集，M代表Modified,NIST代表国家标准和技术研究所，包括从0~9的训练数字的图片，这个分类问题是机器学习最简单和最广泛使用的测试之一。 1、引入MNIST数据集1from tensorflow.examples.tutorials.mnist import input_data 从MNIST_data/中读取MNIST数据。这条语句在数据不存在时，会自动执行下载 1mnist = input_data.read_data_sets(&quot;MNIST_data/&quot;, one_hot=True) 查看训练数据的大小12print(mnist.train.images.shape) # (55000, 784)print(mnist.train.labels.shape) # (55000, 10) 查看验证数据的大小12print(mnist.validation.images.shape) # (5000, 784)print(mnist.validation.labels.shape) # (5000, 10) 查看测试数据的大小12print(mnist.test.images.shape) # (10000, 784)print(mnist.test.labels.shape) # (10000, 10) 将MNIST官网下载的四个数据包放在MNIST_data中。不需要解压，不需要解压，不需要解压。 若没有数据包，Tensorflow会检测到并且会自动下载到MNIST_data文件夹中。 2、保存前30条数据的原始图片12import scipy.miscimport os 我们把原始图片保存在MNIST_data/raw/文件夹下 如果没有这个文件夹会自动创建 123save_dir = &apos;MNIST_data/raw/&apos;if os.path.exists(save_dir) is False: os.makedirs(save_dir) 保存前30张图片123456789101112for i in range(30): # 请注意，mnist.train.images[i, :]就表示第i张图片（序号从0开始） image_array = mnist.train.images[i, :] # TensorFlow中的MNIST图片是一个784维的向量，我们重新把它还原为28x28维的图像。 image_array = image_array.reshape(28, 28) # 保存文件的格式为 mnist_train_0.jpg, mnist_train_1.jpg, ... ,mnist_train_19.jpg filename = save_dir + &apos;mnist_train_%d.jpg&apos; % i # 将image_array保存为图片 # 先用scipy.misc.toimage转换为图像，再调用save直接保存。 scipy.misc.toimage(image_array, cmin=0.0, cmax=1.0).save(filename)print(&apos;Please check: %s &apos; % save_dir) 一、softmax实现单神经元模型1、初始化变量123456import tensorflow as tfx = tf.placeholder(tf.float32,[None,784])W = tf.Variable(tf.zeros([784,10]))b = tf.Variable(tf.zeros([10]))y = tf.nn.softmax(tf.matmul(x,W)+b)y_ = tf.placeholder(tf.float32,[None,10]) 因为图片是28x28像素的，所以1张图片，即x中的一张图片转化成（1,784）的向量，它的便签值y_也转化为向量（1，10）。 因为不确定样本的数量，所以用“占位符（placeholder）”占据一定形式的内存空间，等待用户传值来决定具体的样本数量。我理解成一个有784个小格子高度的容器，由用户来决定有多少个这样的容器。 w,b为“变量”，规定了维度具体大小，即规定了有784个10个格子高度的容器，并把格子中装的值初始化为0。 因为x的值是固定的，所以预测值y的值主要由w,b来决定。 思考：a、占位符和变量的区别是什么？ b、什么是softmax？为什么使用softmax？ 2、向前传播以及损失函数为了确定预测的y与标签值y_的差距，需要定义cost function去评估预测的准确性，即算法的优良性。 1cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_*tf.log(y))) 思考：a、该损失函数的具体原理是什么？ 3、向后传播以及优化参数为了最小化损失函数，需要向后传播计算出dw以及db，即w和b对损失函数的影响程度，然后通过w-学习率dw、b-学习率db更新w和b的值。当然，Tensorflow将这两步通过一行代码同时实现了： 1train_step = tf.train.GradientDescentOptimizer(0.01).minimize(cross_entropy) 代码中学习率为0.01 4、开始训练首先初始化所有变量并申请内存空间： 123init = tf.global_variables_initializer()sess = tf.Session()sess.run(init) 之后，梯度下降1000步： 123for _ in range(1000): batch_xs,batch_ys = mnist.train.next_batch(100) sess.run(train_step,feed_dict=&#123;x:batch_xs,y_:batch_ys&#125;) 运行完后，模型便已被训练完成了，即参数w，b已经被训练好，尽可能的使y（预测值）接近y_（标签纸）,在损失函数的图像上，使值尽可能的接近最凹的点，即最优的点。 5、评估模型123correct_prediction = tf.equal(tf.argmax(y,1),tf.argmax(y_,1))accuracy = tf.reduce_mean(tf.cast(correct_prediction,tf.float32))print(sess.run(accuracy,feed_dict=&#123;x:mnist.test.images,y_:mnist.test.labels&#125;)) 输出0.9168 思考：a、为什么使用tf.argmax来进行评估？ 补充1、占位符和变量的区别是什么？占位符和变量都属于Tensor(张量：一个数组中的元素分布在若干维的规则网格中，则称之为张量)。 占位符不依赖于其他Tensor，具体的值由用户传入，一般用来存储样本数据和标签值。 变量是计算过程中可以改变的值，每次计算后变量的值都会被保存下来，一般用来存储模型的参数。 2、什么是softmax？为什么使用softmax？softmax函数是用于区分多个类别的函数，例如，对（a，b，c）三个类别进行softmax后，每个类别的概率为（,,）,每个数值都在0-1，并且和为1。 相比于“hardmax”只将值表示为0或者1，softmax更详细的输出了每个类别的概率并且能够进行多个类别的判断，所以这里使用它。 3、tf.reduce_mean(-tf.reduce_sum(y_*tf.log(y)))损失函数的具体原理是什么？只从代码来看表示将 公式的矩阵中所有值求和最后再求平均值。因为y的值肯定在0-1之间，为了保证损失值为正，添加符号取负。 若要损失函数的值最小： 当y_向量中某元素为0时，具体含义表示该图片不是某一张图，该项的损失函数值也为0，即相当于最后将10个类别的损失值求和的时候不考虑。 当y_向量中某元素为1时，只有当y的对应元素的值尽可能的接近1时，才尽可能最小，即尽可能接近0。所有让损失值最小的过程就是让预测值y的值无限接近真实值的情况。 4、为什么使用tf.argmax（y,1）来进行评估？该函数表示取得最大值的下标，而值最大的元素的下标值就表示图片中真实数字的值。所以tf.argmax(y_,1)取得的下标值为真实图片的数字值，例如[0,2,7,1]；tf.argmax(y,1)取得y向量中，对每个类别的预测值里最大值的下标值，即预测的图片的数字值，例如[8,2,7,5]。最后tf.equal进行比较，得到类似[0,1,1,0]的数组，通过tf.reduce_mean得到平均值0.5，表示预测准确率。 二、两层卷积网络分类采用单神经元进行预测，最后的准确率为大约为91.6%，采用卷积网络进行图片识别可将准确率提高到99% 1、初始化变量123456789101112import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data#读入数据mnist = input_data.read_data_sets(&quot;MNIST_data/&quot;,one_hot=True)#创建占位符x = tf.placeholder(tf.float32,[None,784])y_ = tf.placeholder(tf.float32,[None,10])#将向量还原,-1表示第一维度由x的具体数据确定，即由x的矩阵中样本个数来确定x_image = tf.reshape(x,[-1,28,28,1]) 2、预定义函数12345678910111213def weight_variable(shape): inital = tf.truncated_normal(shape) return tf.Variable(inital)def bias_variable(shape): inital =tf.constant(0.1,shape=shape) return tf.Variable(inital)def conv2d(x,W): return tf.nn.conv2d(x,W,strides=[1,1,1,1],padding=&apos;SAME&apos;)def max_pool_2x2(x): return tf.nn.max_pool(x, ksize=[1,2,2,1],strides=[1,2,2,1], padding=&apos;SAME&apos;) 分别表示得到一定维度的参数，指定值的偏执项，卷积函数，2x2最大池化函数。 这里池化函数的过滤器为2x2，步长为2x2,当为此情况时，输出图片的维度是输入图片维度的一半。 3、卷积层1234567891011#第一卷积层w_conv1 = weight_variable([5, 5, 1, 32])b_conv1 = bias_variable([32])h_conv1 = tf.nn.relu(conv2d(x_image, w_conv1) + b_conv1)h_pool1 = max_pool_2x2(h_conv1)#第二卷积层w_conv2 = weight_variable([5, 5, 32, 64])b_conv2 = bias_variable([64])h_conv2 = tf.nn.relu(conv2d(h_pool1, w_conv2) + b_conv2)h_pool2 = max_pool_2x2(h_conv2) 第一卷积层：32个5x5的卷积核进行卷积，padding为same，所以h_conv1的维度为(-1,28,28,32)，-1表示该维度由具体样本数量决定；最后经过2x2最大池化卷积，得到h_pool，维度为（-1,14,14,32） 第二卷积层：进行立体卷积，立体卷积时要保证卷积核的通道数与将要处理图片的通道数相同，所以卷积核维度为(5,5,32)，有64个卷积核。h_conv2的维度为(-1,14,14,64)，经过2x2池化层后，h_pool2的维度为(-1,7,7,64) 4、全连接层1234567891011121314#全连接层w_fc1 = weight_variable([7*7*64,1024])b_fc1 = bias_variable([1024])h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, w_fc1)+ b_fc1)#使用dropoutkeep_prob = tf.placeholder(tf.float32)h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)#最后一层全连接层w_fc2 = weight_variable([1024, 10])b_fc2 = bias_variable([10])y_conv = tf.matmul(h_fc1_drop,w_fc2)+b_fc2 第一层全连接层：将h_pool2后三维转化成一维向量，输出1024维的向量；使用dropout，每一步训练时，一定概率的去掉全连接层中某些连接，防止过度拟合。 第二层全连接层：将1024维度h_fc1_drop转化为10个类别的打分。 5、定义交叉熵损失以及测试的准确率y_conv相当于softmax的logit（即wx+b），所以当然可以用softmax定义将其转换为10个类别的概率，再定义交叉熵损失。但是tensorflow有打包好的函数，直接对logit定义交叉熵损失： 12345cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits_v2(labels=y_,logits=y_conv)) 取预测后结果的平均值得到准确率：correct_prediction = tf.equal(tf.argmax(y_conv,1),tf.argmax(y_,1))accuracy = tf.reduce_mean(tf.cast(correct_prediction,tf.float32)) 6、开始训练12345678910111213141516#创建Session，对变量初始化sess = tf.InteractiveSession()sess.run(tf.global_variables_initializer())# 训练20000步for i in range(20000): batch = mnist.train.next_batch(50) # 每100步报告一次在验证集上的准确度 if i % 100 == 0: train_accuracy = accuracy.eval(feed_dict=&#123;x: batch[0], y_: batch[1], keep_prob: 1.0&#125;) print(&quot;step %d, training accuracy %g&quot; % (i, train_accuracy)) train_step.run(feed_dict=&#123;x: batch[0], y_: batch[1], keep_prob: 0.5&#125;)# 训练结束后报告在测试集上的准确度print(&quot;test accuracy %g&quot; % accuracy.eval(feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0&#125;)) 总结 主要完成了Tesorflow建立Softmax回归模型以及两层卷积的神经网络，了解如何读入数据集以及Tensorflow建立模型的基本流程： 创建还没有执行的tensor（以及自定义辅助函数） 给tensor间书写逻辑 初始化各个tensor 建立以及运行会话","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://jmyok.github.io/categories/机器学习/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"https://jmyok.github.io/tags/tensorflow/"}]},{"title":"Localhexonotfound引起的问题","slug":"Localhexonotfound","date":"2018-07-24T13:59:18.000Z","updated":"2018-09-29T08:09:37.744Z","comments":true,"path":"2018/07/24/Localhexonotfound/","link":"","permalink":"https://jmyok.github.io/2018/07/24/Localhexonotfound/","excerpt":"","text":"Local hexo not found 以及 Error -4058之前想更换一个主题，但是因为git速度太慢失败了，其他的操作就没有了，然后就报了Local hexo not found ： ERROR Local hexo not found in G:testERROR Try running: ‘npm install hexo –save’ 之后执行 npm install hexo --save ,出现checkingPermissions Missing错误： npm WARN checkPermissions Missing write access to C:\\Users\\liuyg\\AppData\\Roaming\\npm\\node_modules\\vue-cli\\node_modules\\cliui\\node_modules\\wordwrapnpm ERR! path C:\\Users\\liuyg\\AppData\\Roaming\\npm\\node_modules\\vue-cli\\node_modules\\cliui\\node_modules\\wordwrap 解决： 删除博客目录下的node_modules,再执行 cnpm(淘宝镜像) 重新下载。执行 hexo g 成功 hexo s 无法运行以及访问localhost:4000无法得到页面解决： 1.因为在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下： cnpm install hexo-server --save 安装此server后再试,hexo s问题解决。2.可能是由于部分包没有下载完，执行 cnpm install ,再次访问得到页面。 舒服。","categories":[{"name":"填坑之旅","slug":"填坑之旅","permalink":"https://jmyok.github.io/categories/填坑之旅/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://jmyok.github.io/tags/hexo/"}]},{"title":"如何建立自己的知识体系","slug":"如何建立自己的知识体系","date":"2018-07-23T15:24:27.000Z","updated":"2018-09-29T08:09:02.676Z","comments":true,"path":"2018/07/23/如何建立自己的知识体系/","link":"","permalink":"https://jmyok.github.io/2018/07/23/如何建立自己的知识体系/","excerpt":"","text":"一、如何做笔记能把书中的框架和重点都展现出来或者你用一页纸能把重点说清楚，就算合格。 说理清结构，归纳重点。 舍弃对自己无用的部分， 按自己的理解进行整理,有时会把导图按照7W3H的方式从新做一个思维导图 用自己的话从新表达出来， 是实践，然后根据结果进行调整和改进。不断重复这几步 二、建立初步框架 读过的书，尽可能做成笔记或导图，笔记放在OneNote里。导图放在MindManage里 针对不同的主题，建立思维导图，尽量提练重点，然后在Note或分支中加下注释或出处。 定期整理和汇总，不段调整分支和整体结构。 如果有时间的话，最好做成PPT或写文章，能把所关注的问题，用自己的话给清楚表达出来 不断重复这个过程。 三、资料补充 如果学习的东西是一个专业性比较强的行业 还需要建立自己的专业名词字典 做资料收集工作，定期整理 针对特定大量阅读本专业的期刊杂志和相关资料，提练重点 会记录所有自己学到的东西和心得 把遇到的问题和处理办法单独记录，定期总结和分析 四、其他 当你完全按照这种方式，针对某方面积累几个月或一、二年，基本上可以冒充一下专家，而且业内人很难挑出毛病。上面所的说东西比较宏观，还有很多东西没有说到。比如目标的制定，建立或加入圈子，合作性学习、更有效的实践、辅助技能的锻炼、资料搜索、分类、重复阅读、阅读技巧、有效的记录和表达。实际上对于建立一个知识体系最快最有效的办法，高端访谈和顶级专家的培训，但这二点对于普通人来说基本上无法实现。不过可以折中一下，多请一些业内的专家吃饭，海聊，效果也很不错。 当你自己已经建立一个成体系的框架，总结出不同方法的优缺点，你可以根据自己的情况进行调整。你再接触同类的资料，可以快速忽略雷同的部分，直接关注问题的核心，这时可以节省大量的时间。对于学习方法和时间管理这类通用技能，越早建立一个系统越好，给自己带来的回报越大。当积累到一定程度会从量变产生质变。 原博文：http://www.read.org.cn/html/1336-build-your-own-knowledge-system.html","categories":[{"name":"其它汇总","slug":"其它汇总","permalink":"https://jmyok.github.io/categories/其它汇总/"}],"tags":[{"name":"学习能力","slug":"学习能力","permalink":"https://jmyok.github.io/tags/学习能力/"}]},{"title":"hexo搭建博客","slug":"hexo搭建博客","date":"2018-07-23T07:05:36.000Z","updated":"2018-09-29T08:14:26.814Z","comments":true,"path":"2018/07/23/hexo搭建博客/","link":"","permalink":"https://jmyok.github.io/2018/07/23/hexo搭建博客/","excerpt":"","text":"hexo精简搭建流程及问题（windows） 1—安裝 首先电脑上需要保证有Node.js以及Git 执行npm install -g hexo (-g参数代表的是全局安裝) 如果安装太慢试试淘宝镜像cnpm:npm install -g cnpm –registry=https://registry.npm.taobao.org 2—初始化以及配置 安装成功后，选择好合适的保存博客内容的文件夹,执行 hexo init便会安装相关依赖完成初始化, 一定要在git里面执行,在DOS里执行不会成功创建相应文件夹，之前被坑惨。。。 之后进入 _config.yml 进行配置,其他相应属性都没什么，网上搜索即可知道对应的作用，主要是最后的部署配置项: deploy:type: githubrepository: git@github.com:Yourname/Yourname.git.io.gitbranch: master 这里有三个坑： 在每个属性后面都要空一格 因为github配置了ssh密匙,所以我的repository用的ssh地址的方式。之前https的方式一直报错，越改越错…可能是git的功力不够深厚 在github创建repository时,取名方式为： Yourname.github.io,名字不按规则会导致部署Git page时目录错误，比如之前我的仓库名是Yourname.git.io,部署完成后博客路径为https://Yourname.github.io/Yourname.git.io, 样式全部丢失(???)。 3—部署 执行 hexo g 生成页面, hexo s在localhost：4000查看效果, hexo d执行部署 在github中进入博客的repository的Settings,找到GitHub Pages,选择master,然后save,大约一分钟博客成功部署。但是一般来说 hexo d 后就自动设定好了,第二步可作为检索差错的一个方法。","categories":[{"name":"填坑之旅","slug":"填坑之旅","permalink":"https://jmyok.github.io/categories/填坑之旅/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://jmyok.github.io/tags/hexo/"}]},{"title":"Laravel开发中问题","slug":"Laravel开发中问题","date":"2017-10-06T20:14:33.000Z","updated":"2018-09-29T08:11:24.725Z","comments":true,"path":"2017/10/07/Laravel开发中问题/","link":"","permalink":"https://jmyok.github.io/2017/10/07/Laravel开发中问题/","excerpt":"","text":"(持续更新) Use of undefined constant users - assumed ‘users’解决：模型中表名未加单引号。protected $table = ‘users’; SQLSTATE[HY000]: General error: 1364 Field ‘password’ doesn’t have a default value解决： protected $fillable = [ ‘name’,’email’,’password,’ ]; (可填入字段错误的写入逗号) Type error: Argument 1 passed to Illuminate\\Auth\\EloquentUserProvider::validateCredentials() must be an instance of Illuminate\\Contracts\\Auth\\Authenticatable, instance of App\\Models\\User given, called in /home/vagrant/Code/weibo2/vendor/laravel/framework/src/Illuminate/Auth/SessionGuard.php on line 381解决：新创建的User类继承Model继承错误，应该继承Authenticatable，按照原本框架自带User更改即可，新建模型时需注意。","categories":[],"tags":[{"name":"填坑之旅","slug":"填坑之旅","permalink":"https://jmyok.github.io/tags/填坑之旅/"}]}]}